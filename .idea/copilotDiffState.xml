<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/blitzapp/remote/ui/composables.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/blitzapp/remote/ui/composables.kt" />
              <option name="originalContent" value="package com.blitzapp.remote.ui&#10;&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.util.Base64&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.layout.BoxWithConstraints&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.blitzapp.remote.BluetoothDevice&#10;import com.blitzapp.remote.MediaInfo&#10;import com.blitzapp.remote.WiFiInfo&#10;import com.blitzapp.remote.ui.theme.*&#10;&#10;// Dynamic color data class&#10;data class DynamicColors(&#10;    val primary: Color = PrimaryAccent,&#10;    val secondary: Color = Color(0xFF1F1F1F),&#10;    val background: Color = Color(0xFF121212),&#10;    val surface: Color = Color(0xFF1E1E1E),&#10;    val text: Color = Color.White&#10;)&#10;&#10;// Extract dominant color from artwork bitmap&#10;fun extractColorsFromBitmap(bitmap: Bitmap?): DynamicColors {&#10;    if (bitmap == null) return DynamicColors()&#10;&#10;    return try {&#10;        // Get dominant color from bitmap - using standard API&#10;        val resized = Bitmap.createScaledBitmap(bitmap, 150, 150, true)&#10;&#10;        var dominantColor = PrimaryAccent&#10;        var r = 0L&#10;        var g = 0L&#10;        var b = 0L&#10;        var pixelCount = 0&#10;&#10;        for (i in 0 until resized.width) {&#10;            for (j in 0 until resized.height) {&#10;                val pixel = resized.getPixel(i, j)&#10;                r += android.graphics.Color.red(pixel)&#10;                g += android.graphics.Color.green(pixel)&#10;                b += android.graphics.Color.blue(pixel)&#10;                pixelCount++&#10;            }&#10;        }&#10;&#10;        if (pixelCount &gt; 0) {&#10;            val avgR = (r / pixelCount).toInt()&#10;            val avgG = (g / pixelCount).toInt()&#10;            val avgB = (b / pixelCount).toInt()&#10;            dominantColor = Color(red = avgR, green = avgG, blue = avgB)&#10;        }&#10;&#10;        DynamicColors(&#10;            primary = dominantColor,&#10;            secondary = dominantColor.copy(alpha = 0.6f),&#10;            background = Color(0xFF0D0D0D),&#10;            surface = dominantColor.copy(alpha = 0.1f),&#10;            text = Color.White&#10;        )&#10;    } catch (_: Exception) {&#10;        DynamicColors()&#10;    }&#10;}&#10;&#10;// Calculate contrasting/opposite color for better visibility&#10;fun getContrastingColor(color: Color): Color {&#10;    // Calculate luminance&#10;    val luminance = (0.299 * color.red + 0.587 * color.green + 0.114 * color.blue)&#10;&#10;    // Return white for dark colors, black for light colors&#10;    return if (luminance &gt; 0.5f) Color.Black else Color.White&#10;}&#10;&#10;// Get vibrant opposite color for accents&#10;fun getOppositeColor(color: Color): Color {&#10;    return Color(&#10;        red = 1f - color.red,&#10;        green = 1f - color.green,&#10;        blue = 1f - color.blue,&#10;        alpha = 1f&#10;    )&#10;}&#10;&#10;// Helper function to format doubles&#10;private fun Double.format(decimals: Int) = &quot;%.${decimals}f&quot;.format(this)&#10;&#10;// Helper function to format network speed with auto-scaling&#10;private fun formatSpeed(mbps: Double?): String {&#10;    // Log.d(&quot;wifi speed&quot; , mbps.toString())&#10;    if (mbps == null) return &quot;0 Kbps&quot;&#10;    return when {&#10;        mbps &gt;= 1000 -&gt; &quot;${(mbps / 1000).format(1)} Gbps&quot;&#10;        mbps &gt;= 1 -&gt; &quot;${mbps.format(1)} Mbps&quot;&#10;        else -&gt; &quot;${(mbps * 1024).toInt()} Kbps&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WifiSpeedIndicator(wifiInfo: WiFiInfo?) {&#10;    // Show the indicator if wifi is connected&#10;    if (wifiInfo != null &amp;&amp; wifiInfo.connected == true) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            val downloadSpeed = formatSpeed(wifiInfo.downloadSpeed)&#10;            val uploadSpeed = formatSpeed(wifiInfo.uploadSpeed)&#10;            Text(&#10;                text = &quot;↓$downloadSpeed / ↑$uploadSpeed&quot;,&#10;                color = TextSecondary,&#10;                fontSize = 12.sp,&#10;                modifier = Modifier&#10;                    .background(CardBackground.copy(alpha = 0.8f), RoundedCornerShape(8.dp))&#10;                    .padding(horizontal = 8.dp, vertical = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ErrorCard(error: String?) {&#10;    if (!error.isNullOrEmpty()) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 8.dp),&#10;            colors = CardDefaults.cardColors(containerColor = Error)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(text = &quot;❌&quot;, fontSize = 24.sp)&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;                Text(&#10;                    text = error,&#10;                    color = TextPrimary,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Header(dynamicColors: DynamicColors = DynamicColors()) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(dynamicColors.background)&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;⚡ BLITZ REMOTE&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = dynamicColors.primary,&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConnectionCard(&#10;    isConnected: Boolean,&#10;    onConnect: (String, String, String) -&gt; Unit,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    var ipAddress by remember { mutableStateOf(&quot;192.168.1.109&quot;) }&#10;    var port by remember { mutableStateOf(&quot;8765&quot;) }&#10;    var path by remember { mutableStateOf(&quot;/ws&quot;) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E1E)),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(20.dp)) {&#10;            Text(text = &quot; Connection&quot;, fontSize = 22.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            &#10;            OutlinedTextField(&#10;                value = ipAddress,&#10;                onValueChange = { ipAddress = it },&#10;                label = { Text(&quot;IP Address&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(12.dp)&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            &#10;            OutlinedTextField(&#10;                value = port,&#10;                onValueChange = { port = it },&#10;                label = { Text(&quot;Port&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(12.dp)&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            &#10;            OutlinedTextField(&#10;                value = path,&#10;                onValueChange = { path = it },&#10;                label = { Text(&quot;Path&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(12.dp)&#10;            )&#10;            Spacer(modifier = Modifier.height(20.dp))&#10;            &#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Button(&#10;                    onClick = { onConnect(ipAddress, port, path) },&#10;                    colors = ButtonDefaults.buttonColors(containerColor = PrimaryAccent),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    modifier = Modifier.height(48.dp)&#10;                ) {&#10;                    Text(text = &quot;CONNECT&quot;, fontWeight = FontWeight.Bold)&#10;                }&#10;                Spacer(modifier = Modifier.weight(1f))&#10;                &#10;                Surface(&#10;                    color = if (isConnected) Success else Error,&#10;                    shape = RoundedCornerShape(20.dp)&#10;                ) {&#10;                    Text(&#10;                        text = if (isConnected) &quot;● CONNECTED&quot; else &quot;○ DISCONNECTED&quot;,&#10;                        color = Color.White,&#10;                        fontWeight = FontWeight.Bold,&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NowPlayingCard(&#10;    mediaInfo: MediaInfo?,&#10;    onCommand: (String) -&gt; Unit,&#10;    onColorsUpdate: (DynamicColors) -&gt; Unit = {}&#10;) {&#10;    var dynamicColors by remember { mutableStateOf(DynamicColors()) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF1A1A1A)),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Box(modifier = Modifier.fillMaxWidth()) {&#10;            // Blurred background artwork&#10;            val artworkData = mediaInfo?.albumArt&#10;&#10;            if (!artworkData.isNullOrBlank()) {&#10;                if (artworkData.startsWith(&quot;data:&quot;)) {&#10;                    // Base64 blurred background&#10;                    val imageBitmap = remember(artworkData) {&#10;                        try {&#10;                            val pureBase64 = artworkData.substringAfter(',')&#10;                            val decodedBytes = Base64.decode(pureBase64, Base64.DEFAULT)&#10;                            BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)?.asImageBitmap()&#10;                        } catch (_: Exception) {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    imageBitmap?.let {&#10;                        Image(&#10;                            bitmap = it,&#10;                            contentDescription = null,&#10;                            contentScale = ContentScale.Crop,&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .blur(50.dp)&#10;                        )&#10;                    }&#10;                } else {&#10;                    // CDN URL blurred background&#10;                    AsyncImage(&#10;                        model = artworkData,&#10;                        contentDescription = null,&#10;                        contentScale = ContentScale.Crop,&#10;                        modifier = Modifier&#10;                            .matchParentSize()&#10;                            .blur(50.dp)&#10;                    )&#10;                }&#10;&#10;                // Dark overlay for better text readability&#10;                Box(&#10;                    modifier = Modifier&#10;                        .matchParentSize()&#10;                        .background(Color.Black.copy(alpha = 0.6f))&#10;                )&#10;            }&#10;&#10;            // Content on top of blurred background&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(20.dp)&#10;                    .fillMaxWidth(),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Calculate contrasting color for text&#10;                val textColor = Color.White&#10;                val accentColor = getOppositeColor(dynamicColors.primary)&#10;&#10;                Text(&#10;                    text = &quot; NOW PLAYING&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = accentColor,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Album artwork (sharp, not blurred)&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(200.dp)&#10;                        .clip(RoundedCornerShape(16.dp))&#10;                        .border(3.dp, accentColor, RoundedCornerShape(16.dp))&#10;                        .background(Color.Black)&#10;                ) {&#10;                    if (artworkData.isNullOrBlank()) {&#10;                        Text(&quot;&quot;, fontSize = 80.sp, textAlign = TextAlign.Center, modifier = Modifier.align(Alignment.Center))&#10;                    } else if (artworkData.startsWith(&quot;data:&quot;)) {&#10;                        val imageBitmap = remember(artworkData) {&#10;                            try {&#10;                                val pureBase64 = artworkData.substringAfter(',')&#10;                                val decodedBytes = Base64.decode(pureBase64, Base64.DEFAULT)&#10;                                BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)&#10;                            } catch (_: Exception) {&#10;                                null&#10;                            }&#10;                        }&#10;&#10;                        LaunchedEffect(imageBitmap) {&#10;                            if (imageBitmap != null) {&#10;                                val colors = extractColorsFromBitmap(imageBitmap)&#10;                                dynamicColors = colors&#10;                                onColorsUpdate(colors)&#10;                            }&#10;                        }&#10;&#10;                        if (imageBitmap != null) {&#10;                            Image(&#10;                                bitmap = imageBitmap.asImageBitmap(),&#10;                                contentDescription = &quot;Album Art&quot;,&#10;                                contentScale = ContentScale.Crop,&#10;                                modifier = Modifier.fillMaxSize()&#10;                            )&#10;                        } else {&#10;                            Text(&quot;⚠️&quot;, fontSize = 80.sp, textAlign = TextAlign.Center, modifier = Modifier.align(Alignment.Center))&#10;                        }&#10;                    } else {&#10;                        var imageLoaded by remember(artworkData) { mutableStateOf(false) }&#10;&#10;                        AsyncImage(&#10;                            model = artworkData,&#10;                            contentDescription = &quot;Album Art&quot;,&#10;                            contentScale = ContentScale.Crop,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            onSuccess = { state -&gt;&#10;                                if (!imageLoaded) {&#10;                                    imageLoaded = true&#10;                                    val drawable = state.result.drawable&#10;&#10;                                    val bitmap = when (drawable) {&#10;                                        is android.graphics.drawable.BitmapDrawable -&gt; {&#10;                                            drawable.bitmap&#10;                                        }&#10;                                        else -&gt; {&#10;                                            try {&#10;                                                val width = drawable.intrinsicWidth.takeIf { it &gt; 0 } ?: 100&#10;                                                val height = drawable.intrinsicHeight.takeIf { it &gt; 0 } ?: 100&#10;                                                val bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)&#10;                                                val canvas = android.graphics.Canvas(bmp)&#10;                                                drawable.setBounds(0, 0, canvas.width, canvas.height)&#10;                                                drawable.draw(canvas)&#10;                                                bmp&#10;                                            } catch (_: Exception) {&#10;                                                null&#10;                                            }&#10;                                        }&#10;                                    }&#10;&#10;                                    bitmap?.let {&#10;                                        val colors = extractColorsFromBitmap(it)&#10;                                        dynamicColors = colors&#10;                                        onColorsUpdate(colors)&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = mediaInfo?.title ?: &quot;No Track&quot;,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    color = textColor,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                if (mediaInfo != null &amp;&amp; !mediaInfo.artist.isNullOrBlank()) {&#10;                    Text(&#10;                        text = mediaInfo.artist,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = textColor.copy(alpha = 0.9f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                val progress = (mediaInfo?.position?.toFloat() ?: 0f) / (mediaInfo?.duration?.toFloat() ?: 1f)&#10;                LinearProgressIndicator(&#10;                    { progress },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clip(RoundedCornerShape(4.dp)),&#10;                    color = accentColor,&#10;                    trackColor = textColor.copy(alpha = 0.3f)&#10;                )&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(text = formatTime(mediaInfo?.position), color = textColor.copy(alpha = 0.8f), fontSize = 12.sp)&#10;                    Text(text = formatTime(mediaInfo?.duration), color = textColor.copy(alpha = 0.8f), fontSize = 12.sp)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    IconButton(onClick = { onCommand(&quot;player_prev&quot;) }) {&#10;                        Text(&quot;⏮&quot;, fontSize = 28.sp, color = textColor)&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                    IconButton(&#10;                        onClick = { onCommand(&quot;player_toggle&quot;) },&#10;                        modifier = Modifier&#10;                            .size(56.dp)&#10;                            .background(accentColor, CircleShape)&#10;                    ) {&#10;                        Text(&#10;                            if (mediaInfo?.status == &quot;Playing&quot;) &quot;⏸&quot; else &quot;▶&quot;,&#10;                            fontSize = 28.sp,&#10;                            color = getContrastingColor(accentColor)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                    IconButton(onClick = { onCommand(&quot;player_next&quot;) }) {&#10;                        Text(&quot;⏭&quot;, fontSize = 28.sp, color = textColor)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BluetoothDevicesCard(&#10;    devices: List&lt;BluetoothDevice&gt;,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    if (devices.isNotEmpty()) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E1E)),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(20.dp)) {&#10;                Text(text = &quot; Bluetooth Devices&quot;, fontSize = 22.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                devices.forEachIndexed { index, device -&gt;&#10;                    Surface(&#10;                        color = Color(0xFF2A2A2A),&#10;                        shape = RoundedCornerShape(12.dp)&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Column(modifier = Modifier.weight(1f)) {&#10;                                Text(&#10;                                    text = device.name ?: &quot;Unnamed Device&quot;,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = Color.White,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(4.dp))&#10;                                Text(&#10;                                    text = device.macAddress ?: &quot;No Address&quot;,&#10;                                    fontSize = 12.sp,&#10;                                    color = Color.White.copy(alpha = 0.6f)&#10;                                )&#10;                            }&#10;                            &#10;                            device.battery?.let {&#10;                                Surface(&#10;                                    color = PrimaryAccent,&#10;                                    shape = RoundedCornerShape(8.dp)&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;$it%&quot;,&#10;                                        color = Color.Black,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    &#10;                    if (index &lt; devices.size - 1) {&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun QuickActionsCard(&#10;    onCommand: (String) -&gt; Unit,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    val actions = listOf(&#10;        &quot;player_toggle&quot; to &quot;Play/Pause&quot;,&#10;        &quot;player_next&quot; to &quot;Next&quot;,&#10;        &quot;player_prev&quot; to &quot;Previous&quot;,&#10;        &quot;system_update&quot; to &quot;Update&quot;,&#10;        &quot;list_home&quot; to &quot;List Home&quot;,&#10;        &quot;git_status&quot; to &quot;Git Status&quot;,&#10;        &quot;open_firefox&quot; to &quot;Firefox&quot;,&#10;        &quot;open_vscode&quot; to &quot;VSCode&quot;,&#10;        &quot;open_edge&quot; to &quot;Edge&quot;&#10;    )&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp),&#10;        colors = CardDefaults.cardColors(containerColor = dynamicColors.surface)&#10;    ) {&#10;        Column(modifier = Modifier.padding(16.dp)) {&#10;            Text(text = &quot;Quick Actions&quot;, fontSize = 20.sp, fontWeight = FontWeight.Bold, color = dynamicColors.primary)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            LazyVerticalGrid(&#10;                columns = GridCells.Fixed(2),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                modifier = Modifier.height(200.dp)&#10;            ) {&#10;                items(actions) { (command, label) -&gt;&#10;                    Button(&#10;                        onClick = { onCommand(command) },&#10;                        colors = ButtonDefaults.buttonColors(containerColor = dynamicColors.primary)&#10;                    ) {&#10;                        Text(text = label, color = dynamicColors.background)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SystemOutputCard(&#10;    output: String?,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    if (!output.isNullOrEmpty()) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(containerColor = dynamicColors.surface)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(text = &quot;System Output&quot;, fontSize = 20.sp, fontWeight = FontWeight.Bold, color = dynamicColors.primary)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                Text(&#10;                    text = output,&#10;                    color = dynamicColors.primary,&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    modifier = Modifier&#10;                        .background(Color.Black, RoundedCornerShape(8.dp))&#10;                        .padding(8.dp)&#10;                        .fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatTime(microseconds: Double?): String {&#10;    if (microseconds == null || microseconds &lt;= 0) return &quot;0:00&quot;&#10;    val seconds = (microseconds / 1_000_000).toInt()&#10;    val mins = seconds / 60&#10;    val secs = seconds % 60&#10;    return &quot;$mins:${secs.toString().padStart(2, '0')}&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package com.blitzapp.remote.ui&#10;&#10;import android.graphics.Bitmap&#10;import android.graphics.BitmapFactory&#10;import android.util.Base64&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.blur&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.blitzapp.remote.BluetoothDevice&#10;import com.blitzapp.remote.MediaInfo&#10;import com.blitzapp.remote.WiFiInfo&#10;import com.blitzapp.remote.ui.theme.*&#10;&#10;// Dynamic color data class&#10;data class DynamicColors(&#10;    val primary: Color = PrimaryAccent,&#10;    val secondary: Color = Color(0xFF1F1F1F),&#10;    val background: Color = Color(0xFF121212),&#10;    val surface: Color = Color(0xFF1E1E1E),&#10;    val text: Color = Color.White&#10;)&#10;&#10;// Extract dominant color from artwork bitmap&#10;fun extractColorsFromBitmap(bitmap: Bitmap?): DynamicColors {&#10;    if (bitmap == null) return DynamicColors()&#10;&#10;    return try {&#10;        // Get dominant color from bitmap - using standard API&#10;        val resized = Bitmap.createScaledBitmap(bitmap, 150, 150, true)&#10;&#10;        var dominantColor = PrimaryAccent&#10;        var r = 0L&#10;        var g = 0L&#10;        var b = 0L&#10;        var pixelCount = 0&#10;&#10;        for (i in 0 until resized.width) {&#10;            for (j in 0 until resized.height) {&#10;                val pixel = resized.getPixel(i, j)&#10;                r += android.graphics.Color.red(pixel)&#10;                g += android.graphics.Color.green(pixel)&#10;                b += android.graphics.Color.blue(pixel)&#10;                pixelCount++&#10;            }&#10;        }&#10;&#10;        if (pixelCount &gt; 0) {&#10;            val avgR = (r / pixelCount).toInt()&#10;            val avgG = (g / pixelCount).toInt()&#10;            val avgB = (b / pixelCount).toInt()&#10;            dominantColor = Color(red = avgR, green = avgG, blue = avgB)&#10;        }&#10;&#10;        DynamicColors(&#10;            primary = dominantColor,&#10;            secondary = dominantColor.copy(alpha = 0.6f),&#10;            background = Color(0xFF0D0D0D),&#10;            surface = dominantColor.copy(alpha = 0.1f),&#10;            text = Color.White&#10;        )&#10;    } catch (_: Exception) {&#10;        DynamicColors()&#10;    }&#10;}&#10;&#10;// Calculate contrasting/opposite color for better visibility&#10;fun getContrastingColor(color: Color): Color {&#10;    // Calculate luminance&#10;    val luminance = (0.299 * color.red + 0.587 * color.green + 0.114 * color.blue)&#10;&#10;    // Return white for dark colors, black for light colors&#10;    return if (luminance &gt; 0.5f) Color.Black else Color.White&#10;}&#10;&#10;// Get vibrant opposite color for accents&#10;fun getOppositeColor(color: Color): Color {&#10;    return Color(&#10;        red = 1f - color.red,&#10;        green = 1f - color.green,&#10;        blue = 1f - color.blue,&#10;        alpha = 1f&#10;    )&#10;}&#10;&#10;// Helper function to format doubles&#10;private fun Double.format(decimals: Int) = &quot;%.${decimals}f&quot;.format(this)&#10;&#10;// Helper function to format network speed with auto-scaling&#10;private fun formatSpeed(mbps: Double?): String {&#10;    // Log.d(&quot;wifi speed&quot; , mbps.toString())&#10;    if (mbps == null) return &quot;0 Kbps&quot;&#10;    return when {&#10;        mbps &gt;= 1000 -&gt; &quot;${(mbps / 1000).format(1)} Gbps&quot;&#10;        mbps &gt;= 1 -&gt; &quot;${mbps.format(1)} Mbps&quot;&#10;        else -&gt; &quot;${(mbps * 1024).toInt()} Kbps&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun WifiSpeedIndicator(wifiInfo: WiFiInfo?) {&#10;    // Show the indicator if wifi is connected&#10;    if (wifiInfo != null &amp;&amp; wifiInfo.connected == true) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp),&#10;            contentAlignment = Alignment.TopEnd&#10;        ) {&#10;            val downloadSpeed = formatSpeed(wifiInfo.downloadSpeed)&#10;            val uploadSpeed = formatSpeed(wifiInfo.uploadSpeed)&#10;            Text(&#10;                text = &quot;↓$downloadSpeed / ↑$uploadSpeed&quot;,&#10;                color = TextSecondary,&#10;                fontSize = 12.sp,&#10;                modifier = Modifier&#10;                    .background(CardBackground.copy(alpha = 0.8f), RoundedCornerShape(8.dp))&#10;                    .padding(horizontal = 8.dp, vertical = 4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ErrorCard(error: String?) {&#10;    if (!error.isNullOrEmpty()) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 8.dp, vertical = 8.dp),&#10;            colors = CardDefaults.cardColors(containerColor = Error),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.padding(20.dp),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(text = &quot;⚠️&quot;, fontSize = 28.sp)&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;                Text(&#10;                    text = error,&#10;                    color = Color.White,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 16.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Header(dynamicColors: DynamicColors = DynamicColors()) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .background(dynamicColors.background)&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;⚡ BLITZ REMOTE&quot;,&#10;            fontSize = 32.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = dynamicColors.primary,&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConnectionCard(&#10;    isConnected: Boolean,&#10;    onConnect: (String, String, String) -&gt; Unit,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    var ipAddress by remember { mutableStateOf(&quot;192.168.1.109&quot;) }&#10;    var port by remember { mutableStateOf(&quot;8765&quot;) }&#10;    var path by remember { mutableStateOf(&quot;/ws&quot;) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E1E)),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(20.dp)) {&#10;            Text(text = &quot; Connection&quot;, fontSize = 22.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            &#10;            OutlinedTextField(&#10;                value = ipAddress,&#10;                onValueChange = { ipAddress = it },&#10;                label = { Text(&quot;IP Address&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(12.dp)&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            &#10;            OutlinedTextField(&#10;                value = port,&#10;                onValueChange = { port = it },&#10;                label = { Text(&quot;Port&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(12.dp)&#10;            )&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;            &#10;            OutlinedTextField(&#10;                value = path,&#10;                onValueChange = { path = it },&#10;                label = { Text(&quot;Path&quot;) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(12.dp)&#10;            )&#10;            Spacer(modifier = Modifier.height(20.dp))&#10;            &#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Button(&#10;                    onClick = { onConnect(ipAddress, port, path) },&#10;                    colors = ButtonDefaults.buttonColors(containerColor = PrimaryAccent),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    modifier = Modifier.height(48.dp)&#10;                ) {&#10;                    Text(text = &quot;CONNECT&quot;, fontWeight = FontWeight.Bold)&#10;                }&#10;                Spacer(modifier = Modifier.weight(1f))&#10;                &#10;                Surface(&#10;                    color = if (isConnected) Success else Error,&#10;                    shape = RoundedCornerShape(20.dp)&#10;                ) {&#10;                    Text(&#10;                        text = if (isConnected) &quot;● CONNECTED&quot; else &quot;○ DISCONNECTED&quot;,&#10;                        color = Color.White,&#10;                        fontWeight = FontWeight.Bold,&#10;                        modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp),&#10;                        fontSize = 12.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NowPlayingCard(&#10;    mediaInfo: MediaInfo?,&#10;    onCommand: (String) -&gt; Unit,&#10;    onColorsUpdate: (DynamicColors) -&gt; Unit = {}&#10;) {&#10;    var dynamicColors by remember { mutableStateOf(DynamicColors()) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF1A1A1A)),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Box(modifier = Modifier.fillMaxWidth()) {&#10;            // Blurred background artwork&#10;            val artworkData = mediaInfo?.albumArt&#10;&#10;            if (!artworkData.isNullOrBlank()) {&#10;                if (artworkData.startsWith(&quot;data:&quot;)) {&#10;                    // Base64 blurred background&#10;                    val imageBitmap = remember(artworkData) {&#10;                        try {&#10;                            val pureBase64 = artworkData.substringAfter(',')&#10;                            val decodedBytes = Base64.decode(pureBase64, Base64.DEFAULT)&#10;                            BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)?.asImageBitmap()&#10;                        } catch (_: Exception) {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    imageBitmap?.let {&#10;                        Image(&#10;                            bitmap = it,&#10;                            contentDescription = null,&#10;                            contentScale = ContentScale.Crop,&#10;                            modifier = Modifier&#10;                                .matchParentSize()&#10;                                .blur(50.dp)&#10;                        )&#10;                    }&#10;                } else {&#10;                    // CDN URL blurred background&#10;                    AsyncImage(&#10;                        model = artworkData,&#10;                        contentDescription = null,&#10;                        contentScale = ContentScale.Crop,&#10;                        modifier = Modifier&#10;                            .matchParentSize()&#10;                            .blur(50.dp)&#10;                    )&#10;                }&#10;&#10;                // Dark overlay for better text readability&#10;                Box(&#10;                    modifier = Modifier&#10;                        .matchParentSize()&#10;                        .background(Color.Black.copy(alpha = 0.6f))&#10;                )&#10;            }&#10;&#10;            // Content on top of blurred background&#10;            Column(&#10;                modifier = Modifier&#10;                    .padding(20.dp)&#10;                    .fillMaxWidth(),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Calculate contrasting color for text&#10;                val textColor = Color.White&#10;                val accentColor = getOppositeColor(dynamicColors.primary)&#10;&#10;                Text(&#10;                    text = &quot; NOW PLAYING&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = accentColor,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Album artwork (sharp, not blurred)&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(200.dp)&#10;                        .clip(RoundedCornerShape(16.dp))&#10;                        .border(3.dp, accentColor, RoundedCornerShape(16.dp))&#10;                        .background(Color.Black)&#10;                ) {&#10;                    if (artworkData.isNullOrBlank()) {&#10;                        Text(&quot;&quot;, fontSize = 80.sp, textAlign = TextAlign.Center, modifier = Modifier.align(Alignment.Center))&#10;                    } else if (artworkData.startsWith(&quot;data:&quot;)) {&#10;                        val imageBitmap = remember(artworkData) {&#10;                            try {&#10;                                val pureBase64 = artworkData.substringAfter(',')&#10;                                val decodedBytes = Base64.decode(pureBase64, Base64.DEFAULT)&#10;                                BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)&#10;                            } catch (_: Exception) {&#10;                                null&#10;                            }&#10;                        }&#10;&#10;                        LaunchedEffect(imageBitmap) {&#10;                            if (imageBitmap != null) {&#10;                                val colors = extractColorsFromBitmap(imageBitmap)&#10;                                dynamicColors = colors&#10;                                onColorsUpdate(colors)&#10;                            }&#10;                        }&#10;&#10;                        if (imageBitmap != null) {&#10;                            Image(&#10;                                bitmap = imageBitmap.asImageBitmap(),&#10;                                contentDescription = &quot;Album Art&quot;,&#10;                                contentScale = ContentScale.Crop,&#10;                                modifier = Modifier.fillMaxSize()&#10;                            )&#10;                        } else {&#10;                            Text(&quot;⚠️&quot;, fontSize = 80.sp, textAlign = TextAlign.Center, modifier = Modifier.align(Alignment.Center))&#10;                        }&#10;                    } else {&#10;                        var imageLoaded by remember(artworkData) { mutableStateOf(false) }&#10;&#10;                        AsyncImage(&#10;                            model = artworkData,&#10;                            contentDescription = &quot;Album Art&quot;,&#10;                            contentScale = ContentScale.Crop,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            onSuccess = { state -&gt;&#10;                                if (!imageLoaded) {&#10;                                    imageLoaded = true&#10;                                    val drawable = state.result.drawable&#10;&#10;                                    val bitmap = when (drawable) {&#10;                                        is android.graphics.drawable.BitmapDrawable -&gt; {&#10;                                            drawable.bitmap&#10;                                        }&#10;                                        else -&gt; {&#10;                                            try {&#10;                                                val width = drawable.intrinsicWidth.takeIf { it &gt; 0 } ?: 100&#10;                                                val height = drawable.intrinsicHeight.takeIf { it &gt; 0 } ?: 100&#10;                                                val bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)&#10;                                                val canvas = android.graphics.Canvas(bmp)&#10;                                                drawable.setBounds(0, 0, canvas.width, canvas.height)&#10;                                                drawable.draw(canvas)&#10;                                                bmp&#10;                                            } catch (_: Exception) {&#10;                                                null&#10;                                            }&#10;                                        }&#10;                                    }&#10;&#10;                                    bitmap?.let {&#10;                                        val colors = extractColorsFromBitmap(it)&#10;                                        dynamicColors = colors&#10;                                        onColorsUpdate(colors)&#10;                                    }&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = mediaInfo?.title ?: &quot;No Track&quot;,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    color = textColor,&#10;                    fontWeight = FontWeight.Bold,&#10;                    textAlign = TextAlign.Center&#10;                )&#10;&#10;                if (mediaInfo != null &amp;&amp; !mediaInfo.artist.isNullOrBlank()) {&#10;                    Text(&#10;                        text = mediaInfo.artist,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = textColor.copy(alpha = 0.9f),&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                val progress = (mediaInfo?.position?.toFloat() ?: 0f) / (mediaInfo?.duration?.toFloat() ?: 1f)&#10;                LinearProgressIndicator(&#10;                    { progress },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clip(RoundedCornerShape(4.dp)),&#10;                    color = accentColor,&#10;                    trackColor = textColor.copy(alpha = 0.3f)&#10;                )&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(text = formatTime(mediaInfo?.position), color = textColor.copy(alpha = 0.8f), fontSize = 12.sp)&#10;                    Text(text = formatTime(mediaInfo?.duration), color = textColor.copy(alpha = 0.8f), fontSize = 12.sp)&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    IconButton(onClick = { onCommand(&quot;player_prev&quot;) }) {&#10;                        Text(&quot;⏮&quot;, fontSize = 28.sp, color = textColor)&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                    IconButton(&#10;                        onClick = { onCommand(&quot;player_toggle&quot;) },&#10;                        modifier = Modifier&#10;                            .size(56.dp)&#10;                            .background(accentColor, CircleShape)&#10;                    ) {&#10;                        Text(&#10;                            if (mediaInfo?.status == &quot;Playing&quot;) &quot;⏸&quot; else &quot;▶&quot;,&#10;                            fontSize = 28.sp,&#10;                            color = getContrastingColor(accentColor)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                    IconButton(onClick = { onCommand(&quot;player_next&quot;) }) {&#10;                        Text(&quot;⏭&quot;, fontSize = 28.sp, color = textColor)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BluetoothDevicesCard(&#10;    devices: List&lt;BluetoothDevice&gt;,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    if (devices.isNotEmpty()) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E1E)),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(20.dp)) {&#10;                Text(text = &quot; Bluetooth Devices&quot;, fontSize = 22.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                devices.forEachIndexed { index, device -&gt;&#10;                    Surface(&#10;                        color = Color(0xFF2A2A2A),&#10;                        shape = RoundedCornerShape(12.dp)&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Column(modifier = Modifier.weight(1f)) {&#10;                                Text(&#10;                                    text = device.name ?: &quot;Unnamed Device&quot;,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = Color.White,&#10;                                    fontSize = 16.sp&#10;                                )&#10;                                Spacer(modifier = Modifier.height(4.dp))&#10;                                Text(&#10;                                    text = device.macAddress ?: &quot;No Address&quot;,&#10;                                    fontSize = 12.sp,&#10;                                    color = Color.White.copy(alpha = 0.6f)&#10;                                )&#10;                            }&#10;                            &#10;                            device.battery?.let {&#10;                                Surface(&#10;                                    color = PrimaryAccent,&#10;                                    shape = RoundedCornerShape(8.dp)&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;$it%&quot;,&#10;                                        color = Color.Black,&#10;                                        fontWeight = FontWeight.Bold,&#10;                                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    &#10;                    if (index &lt; devices.size - 1) {&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun QuickActionsCard(&#10;    onCommand: (String) -&gt; Unit,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    val actions = listOf(&#10;        &quot;player_toggle&quot; to &quot;▶️ Play/Pause&quot;,&#10;        &quot;player_next&quot; to &quot;⏭️ Next&quot;,&#10;        &quot;player_prev&quot; to &quot;⏮️ Previous&quot;,&#10;        &quot;system_update&quot; to &quot; Update&quot;,&#10;        &quot;list_home&quot; to &quot; Home&quot;,&#10;        &quot;git_status&quot; to &quot; Git&quot;,&#10;        &quot;open_firefox&quot; to &quot; Firefox&quot;,&#10;        &quot;open_vscode&quot; to &quot; VSCode&quot;,&#10;        &quot;open_edge&quot; to &quot; Edge&quot;&#10;    )&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(8.dp),&#10;        colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E1E)),&#10;        shape = RoundedCornerShape(16.dp),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Column(modifier = Modifier.padding(20.dp)) {&#10;            Text(text = &quot;⚡ Quick Actions&quot;, fontSize = 22.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;            &#10;            LazyVerticalGrid(&#10;                columns = GridCells.Fixed(3),&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp),&#10;                modifier = Modifier.height(240.dp)&#10;            ) {&#10;                items(actions) { (command, label) -&gt;&#10;                    Button(&#10;                        onClick = { onCommand(command) },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF2A2A2A)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(60.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = label,&#10;                            color = Color.White,&#10;                            fontSize = 12.sp,&#10;                            textAlign = TextAlign.Center,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SystemOutputCard(&#10;    output: String?,&#10;    dynamicColors: DynamicColors = DynamicColors()&#10;) {&#10;    if (!output.isNullOrEmpty()) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(8.dp),&#10;            colors = CardDefaults.cardColors(containerColor = Color(0xFF1E1E1E)),&#10;            shape = RoundedCornerShape(16.dp),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(20.dp)) {&#10;                Text(text = &quot; System Output&quot;, fontSize = 22.sp, fontWeight = FontWeight.Bold, color = Color.White)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                Surface(&#10;                    color = Color.Black,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ) {&#10;                    Text(&#10;                        text = output,&#10;                        color = Color(0xFF00FF00),&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatTime(microseconds: Double?): String {&#10;    if (microseconds == null || microseconds &lt;= 0) return &quot;0:00&quot;&#10;    val seconds = (microseconds / 1_000_000).toInt()&#10;    val mins = seconds / 60&#10;    val secs = seconds % 60&#10;    return &quot;$mins:${secs.toString().padStart(2, '0')}&quot;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>